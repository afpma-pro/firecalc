<!--
SPDX-License-Identifier: AGPL-3.0-or-later
Copyright (C) 2025 Association Française du Poêle Maçonné Artisanal
-->

# I18N Translation System Documentation

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Modules Structure](#modules-structure)
4. [Library: Babel](#library-babel)
5. [Build Process](#build-process)
6. [File Locations](#file-locations)
7. [Adding New Translations](#adding-new-translations)
8. [Using Translations in Code](#using-translations-in-code)
9. [Advanced Features](#advanced-features)
10. [Examples](#examples)

---

## Overview

The FireCalc project uses a **type-safe, compile-time verified internationalization (I18N) system** based on the [Babel library](https://github.com/taig/babel) for Scala. The system supports multiple languages (currently English and French) and provides:

- **Type-safe translations** - Compile-time verification of translation keys
- **HOCON-based source files** - Human-readable `.conf` files
- **Auto-generated Scala code** - Translation files compiled into Scala objects during build
- **Context-aware translations** - Support for string formatting with placeholders
- **Modular architecture** - Separate translation modules for different application domains

### Supported Languages
- **English** (`en`) - Primary language
- **French** (`fr`) - Secondary language with fallback to English

---

## Architecture

The I18N system consists of **6 modules** organized in a hierarchical structure:

```
┌─────────────────────────────────────────────────────────────┐
│                     i18n-utils                              │
│         (Core utilities, macros, type-safe paths)           │
└──────────────────────┬──────────────────────────────────────┘
                       │
          ┌────────────┴────────────┬────────────┐
          │                         │            │
┌─────────▼─────────┐  ┌───────────▼──────┐  ┌──▼────────────┐
│       i18n        │  │    ui-i18n       │  │  payments-    │
│  (Core engine     │  │  (UI-specific    │  │  shared-i18n  │
│   translations)   │  │  translations)   │  │               │
└─────────┬─────────┘  └──────────────────┘  └───────────────┘
          │
    ┌─────┴─────┬──────────────┐
    │           │              │
┌───▼──────┐ ┌──▼─────────┐ ┌─▼────────────┐
│payments- │ │ invoices-  │ │    units     │
│  i18n    │ │   i18n     │ │              │
└──────────┘ └────────────┘ └──────────────┘
```

---

## Modules Structure

### 1. `i18n-utils` (Core Utilities)
**Location**: [`modules/i18n-utils/`](modules/i18n-utils/src/main/scala/afpma/firecalc/i18n/utils/)

**Purpose**: Provides foundational utilities for all other i18n modules.

**Key Components**:
- `macros.scala` - Compile-time macros for type-safe translation paths
- Custom type classes and utilities

**Dependencies**:
```scala
libraryDependencies += "io.taig" %%% "babel-loader" % "0.5.3"
libraryDependencies += "pro.afpma" %%% "magnolia" % "1.3.16"  // For @Transl annotation
```

**Platforms**: JVM + JS (cross-compiled)

---

### 2. `i18n` (Core Engine Translations)
**Location**: [`modules/i18n/`](modules/i18n/)

**Purpose**: Core translations used throughout the calculation engine. Contains technical terms, mathematical formulas, standard references (EN 13384, EN 15544), and engineering terminology.

**Translation Files**:
- [`modules/i18n/src/main/resources/i18n/en.conf`](modules/i18n/src/main/resources/i18n/en.conf) - 745 lines
- [`modules/i18n/src/main/resources/i18n/fr.conf`](modules/i18n/src/main/resources/i18n/fr.conf) - 745 lines

**Generated Scala File**: `target/scala-3.7.3/src_managed/main/afpma/firecalc/i18n/files.scala`

**Key Sections**:
- `add_element` - UI elements for adding pipe sections
- `en13384` - EN 13384-1 standard terminology
- `en15544` - EN 15544 standard terminology
- `firebox` - Firebox specifications and types
- `terms` - General technical terms
- `units` - Unit names and conversions

**Dependencies**:
```scala
libraryDependencies += "io.taig" %%% "babel-circe"   % "0.5.3"
libraryDependencies += "io.taig" %%% "babel-generic" % "0.5.3"
libraryDependencies += "io.taig" %%% "babel-loader"  % "0.5.3"
```

**Usage Example**:
```scala
import afpma.firecalc.i18n.implicits.{given, *}

// Type-safe access to translations
val termName = I18N.terms.diameter  // "diameter" (EN) or "diamètre" (FR)
```

---

### 3. `ui-i18n` (UI-Specific Translations)
**Location**: [`modules/ui-i18n/`](modules/ui-i18n/)

**Purpose**: User interface translations for the web application. Contains button labels, tooltips, form fields, and UI-specific terminology.

**Translation Files**:
- [`modules/ui-i18n/src/main/resources/i18n/en.conf`](modules/ui-i18n/src/main/resources/i18n/en.conf)
- [`modules/ui-i18n/src/main/resources/i18n/fr.conf`](modules/ui-i18n/src/main/resources/i18n/fr.conf)

**Generated Scala File**: `target/scala-3.7.3/src_managed/main/afpma/firecalc/ui/i18n/files.scala`

**Key Sections**:
- `buttons` - UI button labels
- `customer` - Customer form fields
- `tooltips` - Hover text and help messages
- `indicators` - Status indicators
- `pdf_ordering` - PDF generation interface

**Platforms**: JS only (ScalaJS for web UI)

---

### 4. `payments-i18n` (Payment Module Translations)
**Location**: [`modules/payments-i18n/`](modules/payments-i18n/)

**Purpose**: Translations for the payment processing backend module.

**Translation Files**:
- [`modules/payments-i18n/src/main/resources/i18n/en.conf`](modules/payments-i18n/src/main/resources/i18n/en.conf)
- [`modules/payments-i18n/src/main/resources/i18n/fr.conf`](modules/payments-i18n/src/main/resources/i18n/fr.conf)

**Generated Scala File**: `target/scala-3.7.3/src_managed/main/afpma/firecalc/payments/i18n/files.scala`

**Platform**: JVM only (backend service)

---

### 5. `invoices-i18n` (Invoice Module Translations)
**Location**: [`modules/invoices-i18n/`](modules/invoices-i18n/)

**Purpose**: Translations for invoice generation and management.

**Translation Files**:
- [`modules/invoices-i18n/src/main/resources/i18n/en.conf`](modules/invoices-i18n/src/main/resources/i18n/en.conf)
- [`modules/invoices-i18n/src/main/resources/i18n/fr.conf`](modules/invoices-i18n/src/main/resources/i18n/fr.conf)

**Generated Scala File**: `target/scala-3.7.3/src_managed/main/afpma/firecalc/invoices/i18n/files.scala`

**Platform**: JVM only

---

### 6. `payments-shared-i18n` (Shared Payment Translations)
**Location**: [`modules/payments-shared-i18n/`](modules/payments-shared-i18n/)

**Purpose**: Shared translations for payment-related functionality used across JVM and JS platforms.

**Translation Files**:
- [`modules/payments-shared-i18n/src/main/resources/i18n/en.conf`](modules/payments-shared-i18n/src/main/resources/i18n/en.conf)
- [`modules/payments-shared-i18n/src/main/resources/i18n/fr.conf`](modules/payments-shared-i18n/src/main/resources/i18n/fr.conf)

**Generated Scala File**: `target/scala-3.7.3/src_managed/main/afpma/firecalc/payments/shared/i18n/files.scala`

**Key Sections**:
- `billing_info` - Billing form fields and labels

**Platforms**: JVM + JS (cross-compiled)

---

## Library: Babel

The project uses **[Babel](https://github.com/taig/babel)** version `0.5.3`, a Scala library for type-safe internationalization.

### Key Babel Components

#### 1. `babel-loader`
Loads translation files and creates `Translations` objects.

#### 2. `babel-generic`
Provides automatic derivation of `Decoder` instances for case classes using Magnolia.

#### 3. `babel-circe`
Integration with Circe JSON library (used in some modules).

### Custom Loader Implementation

The project uses a **custom HOCON loader** instead of Babel's default loader:

**File**: [`modules/i18n/src/main/scala/afpma/firecalc/i18n/customloader.scala`](modules/i18n/src/main/scala/afpma/firecalc/i18n/customloader.scala)

```scala
final class CustomLoader(configs: Map[String, String]) extends Loader[Id]:
    override def load(
        base: String,
        locales: Set[Locale]
    ): Id[Translations[Babel]] =
        val all = locales.toList
            .map { locale =>
                val configContent = configs.getOrElse(
                    locale.printLanguageTag,
                    ""
                )
                (locale, ConfigFactory.parseString(configContent))
            }
            .map { case (locale, config) =>
                toBabel(config).map(Translation(locale, _))
            }
            .map {
                case Left(e)      => throw e
                case Right(value) => value
            }
        Translations.from(all)
```

**Why Custom Loader?**
- Reads HOCON files embedded as Scala strings (generated during SBT build)
- Avoids runtime file system access
- Works in ScalaJS environment
- Provides better error messages

---

## Build Process

The build process **automatically generates Scala code** from HOCON translation files using SBT source generators.

### Process Flow

```
┌─────────────────────────────────────────────────────────────────┐
│  1. HOCON Source Files (.conf)                                  │
│     modules/*/src/main/resources/i18n/{en,fr}.conf              │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. SBT Source Generator (Compile / sourceGenerators)           │
│     - Reads .conf files                                         │
│     - Embeds content as Scala string literals                  │
│     - Watches files for changes (auto-regeneration)             │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Generated Scala Files                                       │
│     target/scala-3.7.3/src_managed/main/.../files.scala         │
│                                                                  │
│     object files {                                              │
│       val en: String = """..."""                                │
│       val fr: String = """..."""                                │
│     }                                                            │
│                                                                  │
│     val configs = Map("en" -> files.en, "fr" -> files.fr)       │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. CustomLoader                                                │
│     - Parses HOCON strings at runtime                           │
│     - Converts to Babel objects                                 │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Type-Safe Decoders                                          │
│     - Babel decodes into case classes (I18nData, etc.)          │
│     - Compile-time type checking                                │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  6. Application Code                                            │
│     - Access via I18N.terms.diameter                            │
│     - Given Locale determines language                          │
└─────────────────────────────────────────────────────────────────┘
```

### SBT Configuration Example

From [`build.sbt`](build.sbt:266-316):

```scala
// i18n module example
Compile / sourceGenerators += Def.task {
    val cachedFun = FileFunction.cached(
        streams.value.cacheDirectory / "i18n"
    ) { (in: Set[File]) =>
        val List(fpath_en, fpath_fr) = in.toList
        
        val i18n_en = Source.fromFile(fpath_en).getLines().mkString("\n")
        val i18n_fr = Source.fromFile(fpath_fr).getLines().mkString("\n")
        
        println(s"=> Importing HOCON files :")
        in.toList.map(f => s"\t${f.getName()}").foreach(println)
        
        val i18n_file = (Compile / sourceManaged).value / "afpma" / "firecalc" / "i18n" / "files.scala"
        
        IO.write(i18n_file, s"""
            |package afpma.firecalc.i18n
            |
            |object files {
            |  val en: String = 
            |    \"\"\"
            |$i18n_en
            |\"\"\"
            |  
            |  val fr: String = 
            |    \"\"\"
            |$i18n_fr
            |\"\"\"
            |}
            |
            |val configs = Map(
            |  "en" -> files.en,
            |  "fr" -> files.fr,
            |)
            |""".stripMargin
        )
        Set(i18n_file)
    }
    
    val inputFile_en = file("modules/i18n/src/main/resources/i18n/en.conf")
    val inputFile_fr = file("modules/i18n/src/main/resources/i18n/fr.conf")
    
    cachedFun(Set(inputFile_en, inputFile_fr)).toSeq
}.taskValue
```

### File Watching

The build configuration includes file watching for automatic regeneration:

```scala
// Make Bloop/Metals watch the i18n conf files for changes
Compile / watchSources ++= Seq(
  file("modules/i18n/src/main/resources/i18n/en.conf"),
  file("modules/i18n/src/main/resources/i18n/fr.conf")
)
```

---

## File Locations

### Translation Source Files (HOCON)

All translation files follow the pattern: `modules/[module-name]/src/main/resources/i18n/{en,fr}.conf`

| Module | English | French |
|--------|---------|--------|
| **i18n** | [`modules/i18n/src/main/resources/i18n/en.conf`](modules/i18n/src/main/resources/i18n/en.conf) | [`modules/i18n/src/main/resources/i18n/fr.conf`](modules/i18n/src/main/resources/i18n/fr.conf) |
| **ui-i18n** | [`modules/ui-i18n/src/main/resources/i18n/en.conf`](modules/ui-i18n/src/main/resources/i18n/en.conf) | [`modules/ui-i18n/src/main/resources/i18n/fr.conf`](modules/ui-i18n/src/main/resources/i18n/fr.conf) |
| **payments-i18n** | [`modules/payments-i18n/src/main/resources/i18n/en.conf`](modules/payments-i18n/src/main/resources/i18n/en.conf) | [`modules/payments-i18n/src/main/resources/i18n/fr.conf`](modules/payments-i18n/src/main/resources/i18n/fr.conf) |
| **invoices-i18n** | [`modules/invoices-i18n/src/main/resources/i18n/en.conf`](modules/invoices-i18n/src/main/resources/i18n/en.conf) | [`modules/invoices-i18n/src/main/resources/i18n/fr.conf`](modules/invoices-i18n/src/main/resources/i18n/fr.conf) |
| **payments-shared-i18n** | [`modules/payments-shared-i18n/src/main/resources/i18n/en.conf`](modules/payments-shared-i18n/src/main/resources/i18n/en.conf) | [`modules/payments-shared-i18n/src/main/resources/i18n/fr.conf`](modules/payments-shared-i18n/src/main/resources/i18n/fr.conf) |

### Scala Type Definitions

Case classes defining the structure of translations:

| Module | Type Definition File |
|--------|---------------------|
| **i18n** | [`modules/i18n/src/main/scala/afpma/firecalc/i18n/I18nData.scala`](modules/i18n/src/main/scala/afpma/firecalc/i18n/I18nData.scala) |
| **ui-i18n** | [`modules/ui-i18n/src/main/scala/afpma/firecalc/ui/i18n/I18nData_UI.scala`](modules/ui-i18n/src/main/scala/afpma/firecalc/ui/i18n/I18nData_UI.scala) |
| **payments-shared-i18n** | [`modules/payments-shared-i18n/src/main/scala/afpma/firecalc/payments/shared/i18n/I18nData_PaymentsShared.scala`](modules/payments-shared-i18n/src/main/scala/afpma/firecalc/payments/shared/i18n/I18nData_PaymentsShared.scala) |

### Generated Files (Build Artifacts)

Generated during compilation (NOT committed to version control):

```
target/scala-3.7.3/src_managed/main/
├── afpma/firecalc/i18n/files.scala
├── afpma/firecalc/ui/i18n/files.scala
├── afpma/firecalc/payments/i18n/files.scala
├── afpma/firecalc/invoices/i18n/files.scala
└── afpma/firecalc/payments/shared/i18n/files.scala
```

---

## Adding New Translations

### Step 1: Choose the Appropriate Module

Determine which module should contain your translations:

- **Core engine terms, standards, technical terminology** → `i18n`
- **UI labels, buttons, tooltips** → `ui-i18n`
- **Payment backend** → `payments-i18n`
- **Invoice generation** → `invoices-i18n`
- **Shared payment (JVM + JS)** → `payments-shared-i18n`

### Step 2: Add to HOCON Files

Edit both `en.conf` and `fr.conf` in the chosen module.

**HOCON Syntax Rules**:
- Use nested objects with `=` and `{}`
- Strings can be quoted or unquoted (quote if special characters)
- Support for placeholders: `{0}`, `{1}`, etc.
- Comments use `#` or `//`

**Example** - Adding a new section to `modules/i18n/src/main/resources/i18n/en.conf`:

```hocon
# English translations
add_element = {
    _self                    = "Add element"
    add_section_element      = "Section ↑"
    # ... existing entries ...
}

# NEW SECTION
chimney_caps = {
    _self                    = "Chimney Caps"
    standard_cap             = "Standard cap"
    anti_downdraft_cap       = "Anti-downdraft cap"
    rotating_cap             = "Rotating cowl"
    cap_height               = "Cap height: {0} cm"
}
```

**French equivalent** in `modules/i18n/src/main/resources/i18n/fr.conf`:

```hocon
# Traductions françaises
add_element = {
    _self                    = "Ajouter un élément"
    add_section_element      = "Élément droit ↑"
    # ... existing entries ...
}

# NOUVELLE SECTION
chimney_caps = {
    _self                    = "Mitres et accessoires"
    standard_cap             = "Mitre standard"
    anti_downdraft_cap       = "Mitre anti-refoulement"
    rotating_cap             = "Mitre rotative"
    cap_height               = "Hauteur de la mitre: {0} cm"
}
```

### Step 3: Update Type Definitions

Add corresponding case classes to the module's `I18nData` file.

**Example** - In [`modules/i18n/src/main/scala/afpma/firecalc/i18n/I18nData.scala`](modules/i18n/src/main/scala/afpma/firecalc/i18n/I18nData.scala):

```scala
// 1. Add to main case class
final case class I18nData(
    add_element: AddElement,
    // ... existing fields ...
    chimney_caps: ChimneyCaps,  // NEW
    // ... other fields ...
)

object I18nData:
    // ... existing case classes ...
    
    // 2. Define nested case class
    case class ChimneyCaps(
        _self: String,
        standard_cap: String,
        anti_downdraft_cap: String,
        rotating_cap: String,
        cap_height: StringFormat1,  // For placeholders like "{0}"
    )
```

**String Format Types**:
- `String` - Plain text, no placeholders
- `StringFormat1` - One placeholder: `{0}`
- `StringFormat2` - Two placeholders: `{0}`, `{1}`
- `StringFormat3` - Three placeholders: `{0}`, `{1}`, `{2}`
- `StringFormat4` - Four placeholders: `{0}`, `{1}`, `{2}`, `{3}`

### Step 4: Add Decoder (if needed)

If you added a new nested case class, add a decoder in the module's `implicits.scala`.

**Example** - In [`modules/i18n/src/main/scala/afpma/firecalc/i18n/implicits.scala`](modules/i18n/src/main/scala/afpma/firecalc/i18n/implicits.scala):

```scala
object implicits {
    // ... existing decoders ...
    
    given Decoder[I18nData.ChimneyCaps] = deriveDecoder[I18nData.ChimneyCaps]
    
    // ... rest of implicits ...
}
```

### Step 5: Compile and Test

```bash
# Recompile the module
sbt "project i18n" compile

# Or compile all
sbt compile

# Check for errors
# - Missing translations
# - Type mismatches
# - Decoder issues
```

The build will automatically:
1. Read your `.conf` files
2. Generate `files.scala` with embedded strings
3. Compile with type checking
4. Validate all translations exist for all languages

### Step 6: Use in Code

```scala
import afpma.firecalc.i18n.implicits.{given, *}

// Access translations
given Locale = Locales.en

val capType = I18N.chimney_caps.standard_cap  // "Standard cap"
val height = I18N.chimney_caps.cap_height.format("25")  // "Cap height: 25 cm"
```

---

## Using Translations in Code

### Basic Usage

```scala
import afpma.firecalc.i18n.implicits.{given, *}
import io.taig.babel.{Locale, Locales}

// Set language context
given Locale = Locales.en  // or Locales.fr

// Access translations
val diameter = I18N.terms.diameter  // "diameter" (EN) or "diamètre" (FR)
val addBtn = I18N.add_element._self  // "Add element" (EN)
```

### With String Formatting

```scala
import afpma.firecalc.i18n.implicits.{given, *}

given Locale = Locales.fr

// One placeholder
val errorMsg = I18N.errors.term_should_be_greater_than
    .format("temperature", "0")
// Result (FR): "'temperature' doit être > 0"

// Multiple placeholders  
val range = I18N.errors.term_should_be_between_inclusive
    .format("pressure", "15", "10", "20")
// Result: "'pressure' = 15, doit être ≥ 10 et ≤ 20"
```

### Language Switching

```scala
def greetUser(locale: Locale): String =
    given Locale = locale
    I18N.customer.first_name  // Language determined by locale

greetUser(Locales.en)  // "First name"
greetUser(Locales.fr)  // "Prénom"
```

### Using in UI Components (Laminar)

```scala
import afpma.firecalc.ui.i18n.implicits.{given, *}
import com.raquo.laminar.api.L.*

def createButton(locale: Locale): Element =
    given Locale = locale
    button(
        I18N_UI.buttons.add,  // Button text from ui-i18n
        onClick --> { _ => /* action */ }
    )
```

### Using Type-Safe Paths with `I()` Macro

The `I()` macro provides compile-time verification of translation paths:

```scala
import afpma.firecalc.i18n.implicits.I

// Create type-safe path
val pathToTerm = I(_.terms.diameter)
// Returns: List("terms", "diameter")

// This would fail at compile-time if path is invalid
// val invalid = I(_.nonexistent.field)  // Compile error!
```

---

## Advanced Features

### 1. Type-Safe Translation Paths

The macro system in [`i18n-utils/macros.scala`](modules/i18n-utils/src/main/scala/afpma/firecalc/i18n/utils/macros.scala) provides compile-time safety:

```scala
inline def I(f: I18nData => String) = macros.tPath[I18nData](f)

// Usage
val path = I(_.terms.diameter)
// Returns: List("terms", "diameter")

// Compile-time verification - this will NOT compile:
// val invalid = I(_.does.not.exist)  // ERROR: value does not exist
```

**How it works**:
- The macro analyzes the lambda function at compile-time
- Extracts the field access path
- Verifies each field exists in the type
- Returns a compile-time constant `List[String]`

### 2. `@Transl` Annotation for Custom Types

Use the `@Transl` annotation (from Magnolia) to specify translation paths for custom types:

```scala
import magnolia1.Transl

@Transl(I(_.firebox_names.traditional))
case class TraditionalFirebox(
    @Transl(I(_.firebox.traditional.width)) width: Double,
    @Transl(I(_.firebox.traditional.depth)) depth: Double
)
```

**Purpose**: 
- Automatically derive localized names for types
- Generate forms with translated labels
- Create documentation with proper terminology

### 3. Accessing Nested Translations Programmatically

```scala
import afpma.firecalc.i18n.utils.macros

val path = List("terms", "diameter")
val translation: Option[String] = macros.accessPath[I18nData, String](I18N, path)
// Returns: Some("diameter") or Some("diamètre") depending on Locale
```

### 4. Custom String Formats

Define custom format types for specific use cases:

```scala
// In I18nData.scala
type StringFormat1 = String  // One placeholder
type StringFormat2 = String  // Two placeholders
// etc.

// Usage in HOCON
dimensions_summary = "{0} (W) x {1} (D) x {2} (H)"

// In code
val summary: StringFormat3 = I18N.firebox.dimensions_summary_w_d_h
val result = summary.format("50cm", "40cm", "60cm")
// Result: "50cm (W) x 40cm (D) x 60cm (H)"
```

### 5. Fallback Language

The system automatically falls back to French if English is not available:

```scala
// In implicits.scala
given I18Ns: NonEmptyTranslations[I18nData] =
    Decoder[I18nData]
        .decodeAll(babels)
        .toOption
        .flatMap(_.withFallback(Locales.fr))
        .getOrElse(throw new IllegalStateException("..."))
```

### 6. Watching for Changes During Development

The build system watches translation files and auto-regenerates on changes:

```scala
// In build.sbt
Compile / watchSources ++= Seq(
  file("modules/i18n/src/main/resources/i18n/en.conf"),
  file("modules/i18n/src/main/resources/i18n/fr.conf")
)
```

When you edit a `.conf` file, SBT automatically:
1. Detects the change
2. Regenerates `files.scala`
3. Recompiles affected code
4. Updates the running application (if using `~compile`)

---

## Examples

### Example 1: Simple Translation

**HOCON** (`en.conf`):
```hocon
buttons = {
    add    = "Add"
    cancel = "Cancel"
    save   = "Save"
}
```

**HOCON** (`fr.conf`):
```hocon
buttons = {
    add    = "Ajouter"
    cancel = "Annuler"
    save   = "Enregistrer"
}
```

**Scala Type Definition**:
```scala
case class Buttons(
    add: String,
    cancel: String,
    save: String
)
```

**Usage**:
```scala
import afpma.firecalc.ui.i18n.implicits.{given, *}

given Locale = Locales.fr
println(I18N_UI.buttons.add)     // "Ajouter"
println(I18N_UI.buttons.cancel)  // "Annuler"
```

### Example 2: Nested Structure with Formatting

**HOCON** (`en.conf`):
```hocon
errors = {
    term_should_be_greater_than = "'{0}' should be > {1}"
    term_should_be_less_than    = "'{0}' should be < {1}"
    term_should_be_between_inclusive = "'{0}' = {1}, should be ≥ {2} and ≤ {3}"
}
```

**HOCON** (`fr.conf`):
```hocon
errors = {
    term_should_be_greater_than = "'{0}' doit être > {1}"
    term_should_be_less_than    = "'{0}' doit être < {1}"
    term_should_be_between_inclusive = "'{0}' = {1}, doit être ≥ {2} et ≤ {3}"
}
```

**Scala Type Definition**:
```scala
case class Errors(
    term_should_be_greater_than: StringFormat2,
    term_should_be_less_than: StringFormat2,
    term_should_be_between_inclusive: StringFormat4
)
```

**Usage**:
```scala
given Locale = Locales.en

val error1 = I18N.errors.term_should_be_greater_than.format("temperature", "0")
// "' temperature' should be > 0"

val error2 = I18N.errors.term_should_be_between_inclusive.format("pressure", "15", "10", "20")
// "'pressure' = 15, should be ≥ 10 and ≤ 20"
```

### Example 3: Real-World Complex Structure

**HOCON** (from actual `i18n/en.conf`):
```hocon
firebox = {
    traditional = {
        firebox_floor_shape                   = "Firebox floor shape"
        depth                                 = "Depth"
        width                                 = "Width"
        width_to_depth_ratio                  = "Width to depth ratio"
        height                                = "Height"
        pressure_loss_coefficient_from_door   = "Pressure loss coefficient from door (ζ)"
        total_air_intake_surface_area_on_door = "Total air intake surface area on door"
    }
}
```

**Scala Type Definition**:
```scala
case class Firebox_15544(
    traditional: Firebox_15544.Traditional,
    // ... other firebox types ...
)

object Firebox_15544:
    case class Traditional(
        firebox_floor_shape: String,
        depth: String,
        width: String,
        width_to_depth_ratio: String,
        height: String,
        pressure_loss_coefficient_from_door: String,
        total_air_intake_surface_area_on_door: String
    )
```

**Usage**:
```scala
val label = I18N.firebox.traditional.width  
// EN: "Width"
// FR: "largeur"

val formula = I18N.firebox.traditional.pressure_loss_coefficient_from_door
// EN: "Pressure loss coefficient from door (ζ)"
// FR: "perte de charge de la porte (ζ)"
```

### Example 4: Using @Transl for Auto-Derived Names

```scala
import magnolia1.Transl
import afpma.firecalc.i18n.implicits.I

@Transl(I(_.pipe_type.chimney))
case class ChimneyPipe(
    @Transl(I(_.terms.diameter)) diameter: Double,
    @Transl(I(_.terms.length)) length: Double
)

// The @Transl annotations can be used by form libraries
// to automatically generate translated labels
```

### Example 5: Dynamic Language Switching

```scala
import afpma.firecalc.i18n.implicits.{given, *}

class MultilingualReport:
    def generateTitle(locale: Locale): String =
        given Locale = locale
        I18N.reports.document.title
    
    def generate(): Unit =
        val enTitle = generateTitle(Locales.en)
        // masonry heater sizing calculation"
        
        val frTitle = generateTitle(Locales.fr)
        // "calcul de dimensionnement de poêle de masse"
```

### Example 6: Using in Pattern Matching

```scala
import afpma.firecalc.i18n.implicits.{given, *}

enum PipeShape:
    case Circle, Rectangle, Square

def getPipeShapeName(shape: PipeShape)(using Locale): String =
    shape match
        case PipeShape.Circle    => I18N.terms.pipe_shape.circle
        case PipeShape.Rectangle => I18N.terms.pipe_shape.rectangle
        case PipeShape.Square    => I18N.terms.pipe_shape.square

given Locale = Locales.en
getPipeShapeName(PipeShape.Circle)  // "round"

given Locale = Locales.fr  
getPipeShapeName(PipeShape.Circle)  // "cercle"
```

---

## Best Practices

### 1. Keep Translations in Sync
- **Always update both `en.conf` and `fr.conf`** when adding translations
- Use the same structure and nesting in both files
- Keep line counts similar for easier comparison

### 2. Use Meaningful Keys
```hocon
# GOOD - descriptive, hierarchical
customer = {
    contact_info = {
        email = "Email address"
        phone = "Phone number"
    }
}

# BAD - cryptic, flat
c1 = "Email address"
c2 = "Phone number"
```

### 3. Group Related Translations
```hocon
# Group by feature/domain
firebox = {
    traditional = { ... }
    ecolabeled = { ... }
    afpma_prse = { ... }
}

# Not scattered
firebox_traditional_width = "..."
button_add = "..."
firebox_ecolabeled_height = "..."
```

### 4. Use String Formats Appropriately
```hocon
# GOOD - using placeholders
error_out_of_range = "Value {0} is out of range [{1}, {2}]"

# BAD - hardcoded values (not reusable)
error_temperature_high = "Temperature 150 exceeds maximum 100"
```

### 5. Document Complex Translations
```hocon
# Explain context for translators
firebox = {
    # AF = German "Aschefach" (ash pit)
    # Used in Austrian eco-label firebox specifications
    ash_pit_height_AF = "Ash pit height (AF)"
}
```

### 6. Test with Both Languages
```scala
// Always test both locales
def testTranslation(): Unit =
    List(Locales.en, Locales.fr).foreach: locale =>
        given Locale = locale
        val text = I18N.terms.diameter
        assert(text.nonEmpty, s"Missing translation for $locale")
```

---

## Troubleshooting

### Issue: "Decoder failed" or "Translation missing"

**Cause**: Mismatch between HOCON structure and Scala case classes.

**Solution**:
1. Check that case class fields match HOCON keys exactly
2. Ensure all nested objects are defined
3. Verify decoder is added to `implicits.scala`

```scala
// Check structure matches
case class Example(
    field_one: String,  // Must match "field_one" in HOCON
    nested: Nested      // Must have "nested { ... }" in HOCON
)
```

### Issue: "Path must be a compile-time constant"

**Cause**: Using runtime values in `I()` macro.

**Solution**: Use only literal field access:

```scala
// GOOD
val path = I(_.terms.diameter)

// BAD - runtime variable
val field = "diameter"
val path = I(x => x.terms.field)  // Won't compile
```

### Issue: Generated files not updating

**Cause**: SBT cache not invalidating.

**Solution**:
```bash
# Clean and recompile
sbt clean
sbt compile

# Or force regeneration
rm -rf target/scala-3.7.3/src_managed/
sbt compile
```

### Issue: Missing translations in one language

**Cause**: Asymmetric updates to `en.conf` and `fr.conf`.

**Solution**:
1. Use diff to compare files:
   ```bash
   diff modules/i18n/src/main/resources/i18n/en.conf \
        modules/i18n/src/main/resources/i18n/fr.conf
   ```
2. Add missing translations
3. Keep files synchronized

---

## Summary

The FireCalc I18N system provides:

✅ **Type-safe** translations verified at compile-time  
✅ **Auto-generated** Scala code from HOCON sources  
✅ **Modular** architecture with 6 specialized modules  
✅ **Cross-platform** support (JVM + ScalaJS)  
✅ **Developer-friendly** with compile-time path checking  
✅ **LLM-friendly** with clear structure and documentation  

**For LLM Agents**: When working with translations, always:
1. Identify the correct module for your translation domain
2. Update both `en.conf` and `fr.conf` simultaneously
3. Add corresponding Scala type definitions
4. Compile to verify structure matches
5. Use type-safe `I()` macro for paths when possible

**For Developers**: Follow the [Adding New Translations](#adding-new-translations) section and refer to [Best Practices](#best-practices) for maintainable translation management.

---

## Quick Reference Card

```scala
// Import translations
import afpma.firecalc.i18n.implicits.{given, *}

// Set language
given Locale = Locales.en  // or Locales.fr

// Access simple translation
val text: String = I18N.terms.diameter

// Access with formatting
val error: String = I18N.errors.term_should_be_greater_than
    .format("temperature", "0")

// Type-safe path
val path: List[String] = I(_.terms.diameter)

// Module-specific imports
import afpma.firecalc.ui.i18n.implicits.{I18N_UI, *}
import afpma.firecalc.payments.shared.i18n.implicits.{I18N_PaymentsShared, *}
```

---

*Last updated: 2025-01-08*  
*FireCalc Project - AFPMA*